{"version":1,"kind":"Article","sha256":"f254c70da355b8b98087c63d8ee64c929ee47c9a2b6e7dca424f2fde1c971b78","slug":"reproducible-research.ci.ci-practices","location":"/reproducible-research/ci/ci-practices.md","dependencies":[],"frontmatter":{"title":"Best Practices and Recommendations","content_includes_title":false,"authors":[{"nameParsed":{"literal":"The Turing Way Community","given":"The Turing Way","family":"Community"},"name":"The Turing Way Community","id":"contributors-myst-generated-uid-0"}],"license":{"content":{"id":"CC-BY-4.0","url":"https://creativecommons.org/licenses/by/4.0/","name":"Creative Commons Attribution 4.0 International","free":true,"CC":true},"code":{"id":"MIT","url":"https://opensource.org/licenses/MIT","name":"MIT License","free":true,"osi":true}},"github":"https://github.com/the-turing-way/the-turing-way","copyright":"2019-2025","numbering":{"title":{"offset":2}},"edit_url":"https://github.com/the-turing-way/the-turing-way/blob/main/book/website/reproducible-research/ci/ci-practices.md","exports":[{"format":"md","filename":"ci-practices.md","url":"/build/ci-practices-4d5bd704e4388a3a592ebf7aa2c357b0.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"heading","depth":2,"position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"text","value":"Small, iterative changes","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"yzjR6xvpQi"}],"identifier":"small-iterative-changes","label":"Small, iterative changes","html_id":"small-iterative-changes","implicit":true,"key":"KaPrTpyKdS"},{"type":"paragraph","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"children":[{"type":"text","value":"One of the most important practices when adopting continuous integration is to encourage project members to make and commit small changes. Small changes minimise the possibility and impact of problems cropping up when theyâ€™re integrated, which minimises the time and effort cost of integration.","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"key":"wbQarbW43e"}],"key":"Gmn7byeqkC"},{"type":"heading","depth":2,"position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"children":[{"type":"text","value":"Trunk-based development","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"OWnNS2mYnk"}],"identifier":"trunk-based-development","label":"Trunk-based development","html_id":"trunk-based-development","implicit":true,"key":"VQ99F43odT"},{"type":"paragraph","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"With trunk-based development, work is done in the main branch of the repository or merged back into the shared repository at frequent intervals. Short-lived feature branches are permissible as long as they represent small changes and are merged back as soon as possible.","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"hGrFsLu2yP"}],"key":"fcY1rcHsQV"},{"type":"paragraph","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"text","value":"The idea behind trunk-based development is to avoid large commits that violate of concept of small, iterative changes discussed above. Code is available to peers early so that conflicts can be resolved when their scope is small.","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"dlrFn7aVki"}],"key":"LH6KYu2Vmm"},{"type":"heading","depth":2,"position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"Keep the building and testing phases fast","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"QrLyTGMM7E"}],"identifier":"keep-the-building-and-testing-phases-fast","label":"Keep the building and testing phases fast","html_id":"keep-the-building-and-testing-phases-fast","implicit":true,"key":"jIcR04n6sk"},{"type":"paragraph","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"Because the build and test steps must be performed frequently, it is essential that these processes be streamlined to minimise the time spent on them. Increases in build time should be treated as a major problem because the impact is compounded by the fact that each commit kicks off a build.","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"uEsxsRTgLz"}],"key":"kgHqwakDNG"},{"type":"paragraph","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"When possible, running different sections of the test suite in parallel can help move the build through the pipeline faster. Care should also be taken to make sure the proportion of each type of test makes sense. Unit tests are typically very fast and have minimal maintenance overhead. In contrast, automated system or acceptance testing is often complex and prone to breakage. To account for this, it is often a good idea to rely heavily on unit tests, conduct a fair number of integration tests, and then back off on the number of later, more complex testing.","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"cjKfKFz8vc"}],"key":"JzsMtBtDt0"},{"type":"heading","depth":2,"position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"children":[{"type":"text","value":"Computational expense","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"R5RteLvIDM"}],"identifier":"computational-expense","label":"Computational expense","html_id":"computational-expense","implicit":true,"key":"MaZjCpAPCg"},{"type":"paragraph","position":{"start":{"line":22,"column":1},"end":{"line":22,"column":1}},"children":[{"type":"text","value":"Some software will require significant compute resource to build and/or run. Examples include weather and climate models. This can make the use of continuous integration impractical as the tests either take too long or use too much resource. Therefore, a compromise needs to be found to balance the risk of incomplete testing against a usable development process.","position":{"start":{"line":22,"column":1},"end":{"line":22,"column":1}},"key":"NOhPm9A3S7"}],"key":"WZcQb2fbyj"},{"type":"paragraph","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"children":[{"type":"text","value":"One approach is to use different levels of testing, with different subgroups being required depending on what is being changed. A common broad subgroup can be used in every case, with additional ones being invoked to test certain areas in more detail. This introduces an element of judgement to the testing process, but can be applied successfully.","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"key":"Ngu7L2nbfi"}],"key":"KjyjwuuVUh"},{"type":"heading","depth":2,"position":{"start":{"line":26,"column":1},"end":{"line":26,"column":1}},"children":[{"type":"text","value":"Dependencies tracking","position":{"start":{"line":26,"column":1},"end":{"line":26,"column":1}},"key":"NzXdlhup2r"}],"identifier":"dependencies-tracking","label":"Dependencies tracking","html_id":"dependencies-tracking","implicit":true,"key":"eupwXRqcUz"},{"type":"paragraph","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"children":[{"type":"text","value":"Checking for dependency updates should be done regularly. It can save a lot of time, avoiding bugs due to code dependent on deprecated functionality. Services such as ","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"IDvMkwPGXS"},{"type":"link","url":"https://david-dm.org/","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"children":[{"type":"text","value":"David","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"MLuE3qpnYo"}],"urlSource":"https://david-dm.org/","key":"oVRMLqvVYs"},{"type":"text","value":" are available for dependency management.","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"YUFxwnGn32"}],"key":"BBpQT205Y5"},{"type":"heading","depth":2,"position":{"start":{"line":30,"column":1},"end":{"line":30,"column":1}},"children":[{"type":"text","value":"Consistency throughout the pipeline","position":{"start":{"line":30,"column":1},"end":{"line":30,"column":1}},"key":"R4fUJ6oa19"}],"identifier":"consistency-throughout-the-pipeline","label":"Consistency throughout the pipeline","html_id":"consistency-throughout-the-pipeline","implicit":true,"key":"cEcXhC73QF"},{"type":"paragraph","position":{"start":{"line":32,"column":1},"end":{"line":32,"column":1}},"children":[{"type":"text","value":"A project should be built once at the beginning of the pipeline, the resulting software should be stored and accessible to later processes without rebuilding. By using the exact same artefact in each phase, you can be certain that you are not introducing inconsistencies as a result of different build tools.","position":{"start":{"line":32,"column":1},"end":{"line":32,"column":1}},"key":"qtft3Q38qI"}],"key":"MdWHyxG1b7"}],"key":"wSVDveyl6H"}],"key":"vwCYFvvlYq"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Building a Block of a Github Actions","url":"/reproducible-research/ci/ci-building-gh-actions","group":"The Turing Way"},"next":{"title":"Checklist and Resources","url":"/reproducible-research/ci/ci-resources","group":"The Turing Way"}}},"domain":"http://localhost:3000"}